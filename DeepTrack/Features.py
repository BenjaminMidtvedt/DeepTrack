from DeepTrack.properties import Property
from DeepTrack.Image import Image
from abc import ABC, abstractmethod
import os
import re
import numpy as np
import copy


class Feature(ABC):
    ''' Base feature class. 
    Features define a image generation process. Each feature takes an
    input image and alters it using the .get() method. Features can be
    added together using the + operator. In that case the left side of
    the + operator will be used as the input for the Feature on the 
    right. 

    Whenever a Feature is initiated, all keyword arguments passed to the
    constructor will be wrapped as a Distribution, and stored to the 
    `properties` field. When a Feature is resolved, a copy of this 
    field is sent as input to the get method, with each value replaced
    by the current_value field of the distribution.


    A typical lifecycle of a feature F is

    F.clear() 
        Clears the internal cache of the feature.
    F.update() 
        Recursively updates the feature and its parent(s).
    F.resolve() 
        Resolves the image generated by the feature.
    
    Properties
    ----------
    properties : dict
        A dict that contains all keyword arguments passed to the
        constructor wrapped a Distributions. A sampled copy of this
        dict is sent as input to the get function, and is appended
        to the properties field of the output image.
    cache: Image
        Stores the output of a `resolve` call. If this is not
        None, it will be returned instead of calling the get method.
    probability: number
        The probability of calling the get function of this feature
        during a `resolve()` call
    parent: Feature | ndarray
        During a `resolve()` call, this will serve as the input
        to the `get()` method. 
    
    Class Properties
    ----------------
    __name__
        Default name of the Feature.

    Methods
    -------
    clear() 
        Cleans up the tree after execution. Default behavior is
        to set the cache field to None and call clear() on
        the parent if it exists.
    update(history : list)
        If self is not in history, it calls the update method
        on the `properties` and `parent` and appends itself to
        the history list.

    resolve(shape : tuple, **kwargs)
        Uses the current_value of the properties field to
        generate an image using the .get() method. If the feature has
        a parent, the output of the resolve() call on the parent is 
        used as the input to the .get() method, otherwise an Image of
        all zeros is used.
    input_shape(shape : tuple)
        Returns the expected input shape of a shape, given an expected
        final shape.
    get_properties()
        Returns a copy of the properties field, with each value
        replaced by the current_value field.
    get_property(key : str)
        Returns the current_value of the field matching the key in properties.
    set_property(key : str, value : any)
        Sets the current_value of the field matching the key in properties.
    getRoot()
        Calls getRoot() on its parent if it has one, else it returns itself.
    setParent(Feature : Feature | ndarray)
        If the feature has no parent, set the parent field to the input feature,
        else create a Group out of iteself, and sets the parent of the group
        to the input feature.
    '''

    __name__ = "Unnamed feature"

    
    def __init__(self, **kwargs):
        ''' Constructor
        All keyword arguments passed to the base Feature class will be 
        wrapped as a Distribution, as such randomized during a update
        step.         
        '''
        properties = getattr(self, "properties", {})
        for key, value in kwargs.items():
            properties[key] = Property(value)  
        self.properties = Properties(**properties)

        # Set up flags



    @abstractmethod
    def get(self, shape, Image, Optics=None):
        pass



    def get_properties(self):
        return self.properties.current_value()
    


    def get_property(self, key, default=None):
        return self.properties[key]
    


    def set_property(self, key, value):
        self.properties[key] = key


    
    def update(self):
        '''
        Updates the state of all properties.
        '''
        self.properties.update()

    def resolve(self, image):
        properties = self.get_properties()
        return self.get(image, **properties)

    def clear(self):
        '''
        Recursively clears the cache property. Should be on each output node between each call to resolve
        to ensure a correct initial state.
        '''
        self.cache = None
        for val in self.__dict__.values():
            if hasmethod(val, 'clear'):
                val.clear()

    def input_shape(self, shape):
        return shape
    


    

    
from utils import hasmethod
class Properties(dict):
    def __init__(self, *args, **kwargs):
        self.data = dict(*args, **kwargs)

    def clear(self):
        for v in self.data.values():
            if hasmethod(v, 'clear'):
                v.clear()
    

    def sample(self):
        sampled_dict = {}
        for key in self.data.keys():
            sampled_dict[key] = self.data[key].sample()
        return sampled_dict



    def update(self):
        for property in self.data.values():
            property.update()



    def __getitem__(self, key):
        return self.data[key].current_value



    def __setitem__(self, key, value):
        self.data[key].current_value = value



    def current_value(self):
        current_value_dict = {}
        for key in self.data.keys():
            current_value_dict[key] = self.data[key].current_value
        return current_value_dict



'''
    Allows a tree of features to be seen as a whole.    
'''
class Group(Feature):
    __name__ = "Group"
    def __init__(self, Features):
        self.properties = {"group": Features}
        super().__init__(group=Feature)


    def input_shape(self,shape):
        return self.properties["group"].input_shape(shape)


    def get(self, shape, Image, group=None, **kwargs):
        return group.resolve(shape, **kwargs)


class Load(Feature):
    __name__ = "Load"
    def __init__(self,
                    path):
        self.path = path
        self.properties = {"path": path}

        # Initiates the iterator
        self.iter = next(self)


    def get(self, shape, image, **kwargs):
        return self.res


    def update(self):
        self.res = next(self.iter)
        super().update()


    def __next__(self):
        while True:
            file = np.random.choice(self.get_files())
            image = np.load(file)
            np.random.shuffle(image)
            for i in range(len(image)):
                yield image[i]


    def setParent(self, F):
        raise Exception("The Load class cannot have a parent. For literal addition, use the Add class")


    def get_files(self):
        if os.path.isdir(self.path):
             return [os.path.join(self.path,file) for file in os.listdir(self.path) if os.path.isfile(os.path.join(self.path,file))]
        else:
            dirname = os.path.dirname(self.path)
            files =  os.listdir(dirname)
            pattern = os.path.basename(self.path)
            return [os.path.join(self.path,file) for file in files if os.path.isfile(os.path.join(self.path,file)) and re.match(pattern,file)]
        
# class Update(Feature):
#     def __init__(rules, **kwargs):
#         self.rules = rules
#         super().__init__(**kwargs)
    
#     def __call__(F):
#         return F + self

#     def __resolve__(self, shape, **kwargs):
        